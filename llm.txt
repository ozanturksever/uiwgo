# UIwGo AI Code Generator Guide

This guide provides a comprehensive overview of the UIwGo framework, designed for AI code generators to create accurate and idiomatic Go code for WebAssembly frontends.

## 1. Project Overview & Philosophy

UIwGo is a browser-first Go framework for building reactive web applications that compile to WebAssembly. Its core philosophy emphasizes:

- **Simplicity & Ergonomics**: A minimal API surface that is easy to learn and use.
- **Type Safety**: Leveraging Go's type system to prevent common web development errors.
- **Fine-Grained Reactivity**: Built on a simple but powerful signal-based reactivity system.
- **Functional & Composable**: UI is built with pure Go functions and composable components.
- **Modern Best Practices**: Inline event binding and automatic cleanup are the default, not the exception.

### Key Features (Actual)

- **Reactivity System**: `Signals`, `Memos`, and `Effects` for state management.
- **Functional Components**: UI is constructed using functions that return `gomponents.Node`.
- **`gomponents` Integration**: Purely Go-based, type-safe HTML construction (no template language).
- **Inline Event Handlers**: A rich set of handlers like `OnClickInline`, `OnInputInline`, `OnEnterInline` for declarative event binding.
- **Application Manager**: Centralized application lifecycle management.
- **Stores**: A pattern for nested, fine-grained reactive state management via `CreateStore`.
- **Resources**: A reactive primitive for handling asynchronous operations, created with `CreateResource`.
- **`shadcn/React` Compatibility**: A bridge to integrate modern React components into a Go application.
- **Built-in Router**: For building Single Page Applications (SPAs).
- **Action System**: A powerful, decoupled system for managing application-wide events, commands, and queries via an event bus.

## 2. Core Reactivity (`reactivity` package)

UIwGo's reactivity model is simple and synchronous.

### 2.1. Signals: The Source of Truth

Signals are the fundamental reactive primitive. They hold a value and notify dependents when it changes.

- **`reactivity.CreateSignal[T](initialValue T) Signal[T]`**: Creates a new signal.
- **`signal.Get() T`**: Reads the signal's value and establishes a reactive dependency.
- **`signal.Set(newValue T)`**: Updates the signal's value, triggering all dependents.

```go
// Create a signal
count := reactivity.CreateSignal(0) // Returns a reactivity.Signal[int]

// Read the value
currentValue := count.Get() // returns 0

// Set the value (this is a reactive update)
count.Set(10)
```

### 2.2. Memos: Computed Reactive Values

Memos are read-only signals that derive their value from other signals. They cache their result and only re-compute when a dependency changes.

- **`reactivity.CreateMemo[T](computeFunc func() T) Signal[T]`**: Creates a computed, read-only signal.

```go
firstName := reactivity.CreateSignal("John")
lastName := reactivity.CreateSignal("Doe")

// This memo automatically depends on firstName and lastName
fullName := reactivity.CreateMemo(func() string {
    return firstName.Get() + " " + lastName.Get()
})

logutil.Log(fullName.Get()) // "John Doe"
firstName.Set("Jane")
logutil.Log(fullName.Get()) // "Jane Doe" (automatically updated)
```

### 2.3. Effects: Running Side-Effects

Effects are used to run code in response to signal changes. They are perfect for interacting with browser APIs, logging, or triggering network requests.

- **`reactivity.CreateEffect(effectFunc func())`**: Creates an effect that runs immediately and whenever its dependencies change.

```go
count := reactivity.CreateSignal(0)

// This effect runs whenever count changes
reactivity.CreateEffect(func() {
    // dom.GetWindow() is from honnef.co/go/js/dom/v2
    dom.GetWindow().Document().SetTitle(fmt.Sprintf("Count is: %d", count.Get()))
})
```

## 3. UI Construction (`gomponents` & `dom` package)

UI is built with functions. There is no special component struct.

### 3.1. Functional Components

A component is simply a Go function that returns a `gomponents.Node`.

```go
import (
    g "github.com/maragudk/gomponents"
    h "github.com/maragudk/gomponents/html"
    "github.com/ozanturksever/uiwgo/reactivity"
    "github.com/ozanturksever/uiwgo/dom"
)

func CounterComponent() g.Node {
    count := reactivity.CreateSignal(0)

    return h.Div(
        h.P(g.Textf("Count: %d", count.Get())), // Reading the signal directly
        h.Button(
            g.Text("Increment"),
            // Use inline event handlers
            dom.OnClickInline(func(el dom.Element) {
                count.Set(count.Get() + 1)
            }),
        ),
    )
}
```

### 3.2. Inline Event Handlers (The Default Pattern)

**Always prefer inline event handlers.** They are declarative, automatically cleaned up, and use efficient event delegation.

```go
// Click event: handler receives the element itself
h.Button(dom.OnClickInline(func(el dom.Element) {
	// ... logic
}))

// Input event: handler receives element, get value from it
h.Input(dom.OnInputInline(func(el dom.Element) {
    value := el.Value() // el.Value() is a shorthand
    textSignal.Set(value)
}))

// Debounced input: useful for search fields
h.Input(dom.OnInputDebouncedInline(func(el dom.Element) {
    searchQuery.Set(el.Value())
}, 250)) // delay in ms

// Keyboard events for "Enter" or "Escape"
h.Input(dom.OnEnterInline(func(el dom.Element) {
	// E.g., submit a form or add a todo item
}))

// Form submission (automatically prevents default)
h.Form(dom.OnSubmitInline(func(el dom.Element, formData map[string]string) {
    logutil.Log("Form submitted with data:", formData)
}))
```

## 4. Major Features & Patterns

### 4.1. Resources: Reactive Async Operations

Resources are the primary way to handle data fetching. They track the `(data, loading, error)` state of an asynchronous operation that is driven by a `source` signal. When the source signal changes, the fetcher function is re-executed.

- **`reactivity.CreateResource[S, T](source Signal[S], fetcher func(S) (T, error)) Resource[T]`**

A `Resource[T]` provides three reactive methods:
- `resource.Data() T`: The latest successful data.
- `resource.Loading() bool`: True while fetching.
- `resource.Error() error`: The last error encountered.

```go
type Post struct { ID int; Title string }

func fetchPost(id int) (Post, error) {
    // In a real app, you'd use js.Global().Call("fetch", ...)
    // This is a simplified example.
    if id <= 0 {
        return Post{}, fmt.Errorf("invalid post ID")
    }
    return Post{ID: id, Title: fmt.Sprintf("Post %d", id)}, nil
}

func PostComponent(initialPostID int) g.Node {
    // 1. A signal to drive the resource. When this changes, the resource refetches.
    postID := reactivity.CreateSignal(initialPostID)

    // 2. The resource itself. It connects the source signal to the async fetcher.
    postResource := reactivity.CreateResource(postID, fetchPost)

    return h.Div(
        h.H2(g.Text("Post Viewer")),
        // This button updates the source signal, triggering a refetch.
        h.Button(
            dom.OnClickInline(func(el dom.Element) {
                postID.Set(postID.Get() + 1)
            }),
            g.Text("Next Post"),
        ),
        // 3. Conditionally render UI based on the resource's state.
        // The .Data(), .Loading(), and .Error() calls are all reactive.
        comps.Case(
            h.When(postResource.Loading, h.P(g.Text("Loading post..."))),
            h.When(func() bool { return postResource.Error() != nil }, h.P(g.Text(postResource.Error().Error()))),
            h.When(true, // Default case
                h.Article(
                    h.H1(g.Text(postResource.Data().Title)),
                    h.P(g.Textf("ID: %d", postResource.Data().ID)),
                ),
            ),
        ),
    )
}
```

### 4.2. Stores: Nested Reactive State

Stores provide fine-grained reactivity for nested objects or slices. This is perfect for complex application state where you want to avoid re-rendering large components when only a small piece of data changes.

- **`reactivity.CreateStore[T](initialValue T) (Store[T], func(...any))`**: Returns a store and a `setState` function.

To read from the store reactively, you **must** use `store.Select(path...).Get()`. To update, you **must** use `setState(path..., value)`.

```go
type Todo struct {
    Text      string
    Completed bool
}

type AppState struct {
    Todos []Todo
    Filter string
}

// 1. Create the store and setState function
appStore, setAppState := reactivity.CreateStore(AppState{
    Todos: []Todo{
        {Text: "Learn UIwGo", Completed: true},
        {Text: "Build an app", Completed: false},
    },
    Filter: "All",
})

// 2. To read reactively, use Select()
completedSignal := reactivity.Adapt[bool](appStore.Select("Todos", 1, "Completed"))

reactivity.CreateEffect(func() {
    // This effect ONLY depends on the 'Completed' field of the second todo.
    logutil.Log("Second todo completed status:", completedSignal.Get())
})

// 3. To write, use the setState function with a path.
// This update will only trigger the effect above.
setAppState("Todos", 1, "Completed", true)

// Example: Get the length of the Todos slice reactively
todosLenSignal := appStore.SelectLen("Todos")
reactivity.CreateEffect(func() {
    logutil.Log("Number of todos:", todosLenSignal.Get())
})

// Example: Update the filter string
setAppState("Filter", "Active")
```

### 4.3. Application Manager & Routing (`appmanager` & `router` packages)

The `AppManager` is the standard way to bootstrap a UIwGo application. It handles initialization, mounting the root component, and integrating the router.

The `router` uses `RouteDefinition`s with `:param` syntax for parameters.

```go
// Define components for different pages
func HomePage(props ...any) any {
    return h.Div(h.H1(g.Text("Welcome Home")))
}
func UserComponent(props ...any) any {
    // Props contain router context
    routeCtx := props[0].(*router.RouteContext)
    id := routeCtx.Params["id"]
    return h.Div(h.H1(g.Textf("Viewing User %s", id)))
}

// main.go
func main() {
    ctx := context.Background()

    // 1. Define routes using the correct :param syntax
    appRoutes := []*router.RouteDefinition{
        router.Route("/", HomePage),
        router.Route("/users/:id", UserComponent),
    }

    // 2. Define the root component, including the router outlet
    rootComponent := func() g.Node {
        return h.Body(
            h.Nav(
                // The router provides the `A` component for navigation
                router.A(h.Href("/"), g.Text("Home")),
                router.A(h.Href("/users/123"), g.Text("User 123")),
            ),
            h.Main(
                // This is where the matched route component will be rendered
                g.ID("router-outlet"),
            ),
        )
    }

    // 3. Configure and initialize the AppManager
    manager := appmanager.NewAppManager(&appmanager.AppConfig{
        Routes: appRoutes,
    })

    if err := manager.Initialize(ctx); err != nil {
        logutil.Log("Failed to initialize app manager:", err)
        return
    }

    // 4. Mount the root component to the DOM
    if err := manager.Mount(rootComponent); err != nil {
        logutil.Log("Failed to mount app:", err)
        return
    }

    select {} // Keep the app running
}
```

### 4.4. React Compatibility (`compat/react` package)

UIwGo can mount and manage React components (e.g., from `shadcn/ui`), providing access to a rich ecosystem of pre-built UI.

- **`react.NewReactBridge()`**: Creates a new bridge instance.
- **`react.GetBridge()`**: Retrieves a shared global bridge instance (after initialization).
- **`bridge.Render(componentName string, props Props, options *RenderOptions)`**: Renders a React component.

```go
// main.go
import (
    "github.com/ozanturksever/uiwgo/compat/react"
    "github.com/ozanturksever/uiwgo/comps"
    "github.com/ozanturksever/uiwgo/dom"
    "github.com/ozanturksever/uiwgo/logutil"
    g "github.com/maragudk/gomponents"
    h "github.com/maragudk/gomponents/html"
    "syscall/js"
)

func ShadcnDemo() g.Node {
    // Get the shared React bridge. Ensure `react.InitializeBridge()` has been called once at startup.
    bridge, err := react.GetBridge()
    if err != nil {
        return h.Div(g.Textf("Failed to get React bridge: %v", err))
    }

    // Use OnInitInline to render the React component when the container div is mounted
    renderReactButton := dom.OnInitInline(func(el dom.Element) {
        props := react.Props{
            "variant": "destructive",
            "children": "Click me (from React)",
            "onClick": js.FuncOf(func(this js.Value, args []js.Value) any {
                logutil.Log("React button clicked!")
                return nil
            }),
        }
        // Render into the element that triggered the init event
        _, err := bridge.Render("Button", props, &react.RenderOptions{
            ContainerID: el.ID(),
        })
        if err != nil {
            logutil.Log("Failed to render React component:", err)
        }
    })

    return h.Div(
        // Container for the React component with an ID and the init handler
        h.Div(g.ID("react-root"), renderReactButton),
        // A standard Go button
        h.Button(
            g.Text("Click me (from Go)"),
            dom.OnClickInline(func (el dom.Element) {
                logutil.Log("Go button clicked!")
            }),
        ),
    )
}
```

## 5. Advanced: The Action System (`action` package)

For complex applications, the `action` package provides a powerful, decoupled event bus system for managing state, commands, and queries. It is a mature and available feature.

### 5.1. Core Concepts

- **Bus**: The central message bus. You can use a `action.Global()` singleton or create local buses with `action.New()`.
- **Action**: A message dispatched on the bus, typically with a `Type` and `Payload`.
- **Dispatch**: Sends an action to all interested subscribers.
- **Subscribe**: Listens for actions of a specific type.
- **Query/Ask**: A request/response pattern for fetching data through the bus.

### 5.2. Basic Usage: Dispatch and Subscribe

```go
bus := action.Global()

// Define action types
const (
    UserLoggedInAction = "user:logged-in"
    UpdateThemeAction  = "theme:update"
)

// Subscriber component/service
func SetupThemeListener() {
    bus.Subscribe(UpdateThemeAction, func(act action.Action[string]) error {
        logutil.Logf("Theme update received. New theme: %s", act.Payload)
        // ... apply theme
        return nil
    })
}

// Dispatcher component/service
func UserLoginComponent() g.Node {
    return h.Button(
        g.Text("Log In"),
        dom.OnClickInline(func(el dom.Element) {
            // Dispatch a simple action with a string type
            bus.Dispatch(UserLoggedInAction)

            // Dispatch an action with a payload
            bus.Dispatch(action.Action[string]{
                Type:    UpdateThemeAction,
                Payload: "dark",
            })
        }),
    )
}
```

### 5.3. Query/Ask Pattern

The query pattern allows one part of an application to request data from another without a direct dependency.

```go
bus := action.Global()

// Define query type
const GetUserQuery = "query:user"

// The service that has the data handles the query
func SetupUserQueryHandler() {
    type User struct { Name string; Email string }

    bus.HandleQuery(GetUserQuery, func(q action.Action[string]) (any, error) {
        userID := q.Payload
        if userID == "1" {
            return User{Name: "John Doe", Email: "john@example.com"}, nil
        }
        return nil, fmt.Errorf("user not found")
    })
}

// The component that needs the data asks for it
func UserProfile() g.Node {
    userSignal := reactivity.CreateSignal("Loading user...")

    dom.OnInitInline(func(el dom.Element) {
        go func() {
            // Ask for user data via the bus
            res, err := bus.Ask(GetUserQuery, action.Action[string]{Payload: "1"})
            if err != nil {
                userSignal.Set(err.Error())
                return
            }
            if user, ok := res.(User); ok {
                userSignal.Set(fmt.Sprintf("User: %s", user.Name))
            }
        }()
    })

    return h.Div(
        h.P(g.Text(userSignal.Get())),
    )
}
```

### 5.4. What to Generate

Generate code that uses `Signals`, `Memos`, `Effects`, `Resources`, and `Stores` for local and component-level state. For cross-cutting concerns, global state changes, or decoupled communication, use the `action` package.